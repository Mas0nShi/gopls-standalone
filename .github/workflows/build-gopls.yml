# .github/workflows/build-gopls.yml

name: Build and Release gopls on Update

on:
  # 定时触发：每天 UTC 时间 8:00 运行一次
  schedule:
    - cron: '0 8 * * *'
  # 仍然保留手动触发的选项
  workflow_dispatch:

# 设置权限，允许 Action 创建 Release
permissions:
  contents: write

jobs:
  check-version:
    name: Check for new gopls version
    runs-on: ubuntu-latest
    outputs:
      needs_update: ${{ steps.check.outputs.needs_update }}
      new_version: ${{ steps.check.outputs.new_version }}

    steps:
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.0'
          check-latest: true

      - name: Check versions
        id: check
        env:
          # 需要 GitHub Token 来查询你仓库的 releases
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 1. 获取你仓库最新的 release tag (代表你已有的版本)
          # 'gh release list' 需要 gh cli，它在 github runner 中预装了
          # --limit 1 获取最新的一个
          # || true 是为了防止在没有任何 release 时命令失败
          LATEST_RELEASE_TAG=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' || true)
          # 如果没有 release，就设置一个不存在的版本号
          if [ -z "$LATEST_RELEASE_TAG" ]; then
            LATEST_RELEASE_TAG="v0.0.0"
          fi
          echo "Latest release in this repository: $LATEST_RELEASE_TAG"

          # 2. 获取 gopls 的最新版本号
          # go list -m -json 会输出包含版本信息的 JSON
          # jq -r .Version 从 JSON 中提取版本号
          LATEST_GOPLS_VERSION=$(go list -m -json golang.org/x/tools/gopls@latest | jq -r .Version)
          echo "Latest official gopls version: $LATEST_GOPLS_VERSION"

          # 3. 比较版本号
          if [ "$LATEST_RELEASE_TAG" == "$LATEST_GOPLS_VERSION" ]; then
            echo "gopls is up to date."
            echo "needs_update=false" >> $GITHUB_OUTPUT
          else
            echo "New gopls version found! Will trigger build."
            echo "needs_update=true" >> $GITHUB_OUTPUT
            echo "new_version=${LATEST_GOPLS_VERSION}" >> $GITHUB_OUTPUT
          fi

  build:
    name: Build gopls
    # 依赖 check-version 作业
    needs: check-version
    # 仅当 check-version 的输出 needs_update 为 'true' 时运行
    if: needs.check-version.outputs.needs_update == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        goos: [ linux, windows, darwin ]
        goarch: [ amd64, arm64 ]

    steps:
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.0'
          check-latest: true

      - name: Compile gopls for ${{ matrix.goos }}/${{ matrix.goarch }}
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: |
          # 1: 创建一个临时模块环境
          mkdir temp-module
          cd temp-module
          go mod init temp
          # 2. 下载
          echo "Downloading gopls@${{ needs.check-version.outputs.new_version }}..."
          go get golang.org/x/tools/gopls@${{ needs.check-version.outputs.new_version }}

          # 3. 使用 'go build' 进行编译
          BINARY_NAME="gopls-${{ matrix.goos }}-${{ matrix.goarch }}"
          if [ "${{ matrix.goos }}" == "windows" ]; then
            BINARY_NAME="${BINARY_NAME}.exe"
          fi

          echo "Building ${BINARY_NAME}..."
          go build -o "${BINARY_NAME}" -ldflags="-s -w" golang.org/x/tools/gopls
          # 4. 创建打包目录结构
          PACKAGE_DIR="gopls-${{ matrix.goos }}-${{ matrix.goarch }}"
          mkdir -p "../${PACKAGE_DIR}/bin"

          # 5. 移动二进制文件到指定结构中
          mv "${BINARY_NAME}" "../${PACKAGE_DIR}/bin/"
          cd ..
          # 6. 创建 ZIP 压缩包
          ZIP_NAME="${PACKAGE_DIR}.zip"
          # 在 PACKAGE_DIR 目录内执行 zip，以确保 zip 包内的根目录是 bin
          cd "${PACKAGE_DIR}"
          zip -r "../${ZIP_NAME}" .
          cd ..
          echo "Created package: ${ZIP_NAME}"

          echo "ASSET_PATH=${ZIP_NAME}" >> $GITHUB_ENV
      - name: Release
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ env.ASSET_PATH }}
