# .github/workflows/build-gopls.yml

name: Build and Release gopls on Update

on:
  # 定时触发：每天 UTC 时间 8:00 运行一次
  schedule:
    - cron: '0 8 * * *'
  # 仍然保留手动触发的选项
  workflow_dispatch:

# 设置权限，允许 Action 创建 Release
permissions:
  contents: write

jobs:
  check-version:
    name: Check for new gopls version
    runs-on: ubuntu-latest
    outputs:
      needs_update: ${{ steps.check.outputs.needs_update }}
      new_version: ${{ steps.check.outputs.new_version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.0'
          check-latest: true

      - name: Check versions
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 步骤 1: 尝试使用新版 gh 命令获取最新 release tag
          # 我们不使用 '|| true'，以便可以捕获它的退出码
          echo "Attempting to get latest release tag with modern 'gh' command..."
          LATEST_RELEASE_TAG=$(gh release list --limit 1 --json tagName --jq '.[0].tagName')
          
          # 步骤 2: 检查上一个命令的退出码
          # 如果退出码不为 0，说明命令本身失败了 (很可能是因为 gh 版本太旧)
          if [ $? -ne 0 ]; then
            echo "Modern command failed. Falling back to legacy-compatible command..."
            # 尝试使用旧版本也兼容的命令。
            # 这里的 '|| true' 很重要，因为它能处理“确实没有 release”导致此命令也失败的情况，
            # 确保在这种情况下 LATEST_RELEASE_TAG 是一个安全的空字符串。
            LATEST_RELEASE_TAG=$(gh release view --json tagName --jq .tagName || true)
          fi

          # 步骤 3: 报告最终获取到的 tag
          if [ -z "$LATEST_RELEASE_TAG" ]; then
            echo "No existing release found in this repository."
          else
            echo "Latest release in this repository: $LATEST_RELEASE_TAG"
          fi

          # 步骤 4: 获取 gopls 的最新版本号
          LATEST_GOPLS_VERSION=$(go list -m -json golang.org/x/tools/gopls@latest | jq -r .Version)
          echo "Latest official gopls version: $LATEST_GOPLS_VERSION"

          # 步骤 5: 比较版本号
          # 如果 LATEST_RELEASE_TAG 为空，这个比较会是 false，正确触发第一次构建
          if [ "$LATEST_RELEASE_TAG" == "$LATEST_GOPLS_VERSION" ]; then
            echo "gopls is up to date."
            echo "needs_update=false" >> $GITHUB_OUTPUT
          else
            echo "New gopls version found! Will trigger build."
            echo "needs_update=true" >> $GITHUB_OUTPUT
            echo "new_version=${LATEST_GOPLS_VERSION}" >> $GITHUB_OUTPUT
          fi
  build:
    name: Build gopls
    # 依赖 check-version 作业
    needs: check-version
    # 仅当 check-version 的输出 needs_update 为 'true' 时运行
    if: needs.check-version.outputs.needs_update == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        goos: [ linux, windows, darwin ]
        goarch: [ amd64, arm64 ]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.0'
          check-latest: true

      - name: Compile gopls for ${{ matrix.goos }}/${{ matrix.goarch }}
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: |
          # 1: 创建一个临时模块环境
          mkdir temp-module
          cd temp-module
          go mod init temp
          # 2. 下载
          echo "Downloading gopls@${{ needs.check-version.outputs.new_version }}..."
          go get golang.org/x/tools/gopls@${{ needs.check-version.outputs.new_version }}

          # 3. 使用 'go build' 进行编译
          BINARY_NAME="gopls-${{ matrix.goos }}-${{ matrix.goarch }}"
          if [ "${{ matrix.goos }}" == "windows" ]; then
            BINARY_NAME="${BINARY_NAME}.exe"
          fi

          echo "Building ${BINARY_NAME}..."
          go build -o "${BINARY_NAME}" -ldflags="-s -w" golang.org/x/tools/gopls
          # 4. 创建打包目录结构
          PACKAGE_DIR="gopls-${{ matrix.goos }}-${{ matrix.goarch }}"
          mkdir -p "../${PACKAGE_DIR}/bin"

          # 5. 移动二进制文件到指定结构中
          mv "${BINARY_NAME}" "../${PACKAGE_DIR}/bin/gopls"
          cd ..
          # 6. 创建 ZIP 压缩包
          ZIP_NAME="${PACKAGE_DIR}.zip"
          # 在 PACKAGE_DIR 目录内执行 zip，以确保 zip 包内的根目录是 bin
          cd "${PACKAGE_DIR}"
          zip -r "../${ZIP_NAME}" .
          cd ..
          echo "Created package: ${ZIP_NAME}"

      - name: Upload gopls artifact
        uses: actions/upload-artifact@v4
        with:
          # 上传唯一的 ZIP 包作为构件
          name: gopls-zip-${{ matrix.goos }}-${{ matrix.goarch }}
          path: gopls-*.zip
          retention-days: 1
          
  create-release:
    name: Create GitHub Release
    needs: [check-version, build]
    if: needs.check-version.outputs.needs_update == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Download all artifacts
        uses: actions/download-artifact@v5
        with:
          merge-multiple: true
          path: ./artifacts

      - name: Create Release and Upload Assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ needs.check-version.outputs.new_version }}"
          
          # 创建 Release，但不附加文件，--generate-notes 会自动生成更新日志
          gh release create "$TAG" \
            --title "gopls ${TAG}" \
            --generate-notes
          
          # 使用 find 命令找到所有下载的 zip 包并上传
          # 这比之前的 find 命令更简洁，因为我们知道所有要上传的都是 .zip 文件
          find ./artifacts -type f -name "*.zip" -exec gh release upload "$TAG" {} +
